  (define (read2 port)
     ;; (define standard-delimiters
     ;;  (list->string (list #\space #\( #\) #\newline #\" #\; #\"
     ;;                      (integer->char 13) (integer->char 9))))
     (define (eat char)
       (display "eat")
       (newline)
      (if (or (and (char? char) (char=? char (read-char port)))
              (member (read-char port) char))
          #t
          (error "Expecting other character -- READ" port char)))
    ;; (define (read-until char)
    ;;   (define (iter res)
    ;;     (if (or (eof-object? (peek-char port))
    ;;             (and (char? char) (char=? (peek-char port) char))
    ;;             (and (string? char) (member (peek-char port)
    ;;                                   (string->list char)))
    ;;             (and (list? char) (member (peek-char port) char)))
    ;;         (list->string (reverse res))
    ;;         (iter (cons (read-char port) res))))
    ;;   (iter '()))
    ;; (define (eat-whitespace)
    ;;   (display "eat-whitespace")
    ;;   (display port)
    ;;   (newline)
    ;;   (if (begin (display "before char-whitespace ")
    ;;              (newline)
    ;;              (let ((v (char-whitespace? (peek-char port))))
    ;;                (display "after char-whitespace ")
    ;;                (newline)
    ;;                (display v)
    ;;                (newline)
    ;;                v))
    ;;       (begin (display "before read-char ")
    ;;              (newline)
    ;;              (read-char port)
    ;;              (display "after read-char")
    ;;              (newline)
    ;;              (eat-whitespace))))
    ;; (define (fix-improper head tail)
    ;;   (display "fix-improper")
    ;;   (newline)
    ;;   (if (null? head)
    ;;       tail
    ;;       (fix-improper (cdr head) (cons (car head) tail))))
    (define (read-list l)
      (display "read-list")
      (newline)
;      (eat-whitespace)
      (cond ((eof-object? (begin (display "before rl-peek-char")
                                 (newline)
                                 (let ((r (peek-char port)))
                                   (display "1after peek-char-")
                                   (newline)
                                   (display r)
                                   (newline)
                                   r)))
             (error 
              "Input was terminated while looking for a closing parens."))
            ((let ((r2 (char=? (begin (display "2nd peek-char")
                                      (newline)
                                      (let ((r (peek-char port)))
                                        (display "2ndafter peek-char============")
                                        (newline)
                                        (display r)
                                        (newline)
                                        r))
                               #\))))
               (display "r2")
               (newline)
               (display r2)
               (newline)
               r2)
             (display "read close paren")
             (newline)
             (read-char port) (reverse l))
            (else
             (display "read-list else")
             (newline)
             (let ((elem (read2 port)))
;               (if (and (symbol? elem) (string=? "." (symbol->string elem)))
;                   (let ((ans (fix-improper l (read2 port))))
;                     (eat-whitespace)
;                     (eat #\))
;                     ans)
                   (read-list (cons elem l))
;                   )
               ))))
    (define (read-string res)
      (display "read-string")
      (newline)
      (let ((char (read-char port)))
        (cond ((eof-object? char) (list->string (reverse res)))
              ((char=? #\\ char) (read-string (cons (read-char port) res)))
              ((char=? #\" char) (list->string (reverse res)))
              (else (read-string (cons char res))))))
;;     (define (read-char-lit)
;;       (eat #\\)
;;       (case (peek-char port)
;;         ((#\; #\( #\) #\" #\;) (read-char port))
;;         ((#\space #\newline (integer->char 13))
;;          (error "Invalid character constant." (peek-char port)))
;;         (else
;;          (if (eof-object? (peek-char port))
;;              (error "Reached end-of-file in character constant.")
;;              (let ((name (read-until standard-delimiters)))
;;                (if (= (string-length name) 1)
;;                    (string-ref name 0)
;;                    (let ((char (assoc name '(("newline" . #\newline)
;;                                              ("space" . #\space)
;;                                              ("tab" . (integer->char #x09))))))
;;                      (if char
;;                          (cdr char)
;;                          (error "An invalid character name was specified."
;;                                 name)))))))))
;;     (define (string-is-number? string)
;;       (define (iter i exact radix minus decimal letters)
;;         (cond ((>= i (string-length string)) #t)
;;               ((and (char=? #\# (string-ref string i))
;;                     (member (string-ref string (+ i 1))
;;                       '(#\e #\i #\E #\I)))
;;                (iter (+ i 2) #f radix minus decimal letters))
;;               ((and (char=? #\# (string-ref string i))
;;                     (member (string-ref string (+ i 1))
;;                       '(#\x #\d #\o #\b)))
;;                (iter (+ i 2) exact #f minus decimal letters))
;;               ((and (char=? #\- (string-ref string i))
;;                     minus
;;                     decimal
;;                     letters)
;;                (and (< i (- (string-length string) 1))
;;                     (iter (+ i 1) #f #f #f decimal letters)))
;;               ((char=? #\. (string-ref string i))
;;                (and decimal
;;                     (> (string-length string) 1)
;;                     (iter (+ i 1) #f #f #f #f letters)))
;;               ((char-numeric? (string-ref string i))
;;                (iter (+ i 1) #f #f #f decimal letters))
;;               ((member (char-upcase (string-ref string i))
;;                  '(#\F #\S #\D #\L))
;;                (and letters
;;                     (> i 0)
;;                     (< (+ i 1) (string-length string))
;;                     (char-numeric? (string-ref string (+ i 1)))
;;                     (iter (+ i 1) #f #f #f #f #f)))
;;               (else #f)))
                                        ;b;       (iter 0 #t #t #t #t #t))
    (display "read2 let*")
    (newline)
    (let* ((char (begin (read-char port)))
           (next (begin (if (eof-object? char) char (peek-char port)))))
       (cond ((eof-object? char) char)
;;             ((char=? #\; char) (begin (read-until #\newline)
;;                                       (read2 port)))
;;             ((char-whitespace? char) (read2 port))
;;             ((and (char=? #\# char) (char=? #\\ next))
;;              (read-char-lit))
;;             ((and (char=? #\# char) (char=? #\t (char-downcase next)))
;;              (begin (read-char port)
;;                     #t))
;;             ((and (char=? #\# char) (char=? #\f (char-downcase next)))
;;              (begin (read-char port)
;;                     #f))
;;             ((and (char=? #\# char) (char=? #\( next))
;;              (read-char port) (list->vector (read-list '())))
;; ;#IFDEF READER_EXTENSIONS
;;             ((and (char=? #\# char) (assoc next *reader-extensions*))
;;              (let ((reader (cdr (assoc next *reader-extensions*))))
;;                (reader port)))
;; ;#ENDIF READER_EXTENSIONS
;;             ((char=? #\' char) (list 'quote (read2 port)))
;;             ((char=? #\` char) (list 'quasiquote (read2 port)))
;;             ((char=? #\, char) (if (char=? next #\@)
;;                                    (begin (read-char port)
;;                                           (list 'unquote-splicing
;;                                                 (read2 port)))
;;                                    (list 'unquote (read2 port))))
             ((char=? #\" char)
              (read-string '()))
             ((char=? #\( char) (read-list '()))
             (else char))))
;;                (if (string-is-number? the-string)
;;                    (string->number the-string)
;;                    (string->symbol the-string)))))))

(define f (open-input-file "tests/read-dat.scm"))
(display (input-port? f))
(newline)
(define c (read2 f))
(display c)
(newline)
(close-input-port f)
