
;; (define (read2 . port)
;;   (define (read port)
;;     (define standard-delimiters 
;;       (list->string (list #\space #\( #\) #\newline #\" #\; #\"
;;                           (integer->char 13) (integer->char 9))))
;;     (define (eat char)
;;       (if (or (and (char? char) (char=? char (read-char port)))
;;               (member (read-char port) char))
;;           #t
;;           (error "Expecting other character -- READ" port char)))
;;     (define (read-until char)
;;       (define (iter res)
;;         (if (or (eof-object? (peek-char port))
;;                 (and (char? char) (char=? (peek-char port) char))
;;                 (and (string? char) (member (peek-char port) 
;;                                       (string->list char)))
;;                 (and (list? char) (member (peek-char port) char)))
;;             (list->string (reverse res))
;;             (iter (cons (read-char port) res))))
;;       (iter '()))
;;     (define (eat-comment)
;;       (read-until #\newline))
;;     (define (eat-whitespace)
;;       (if (char-whitespace? (peek-char port))
;;           (begin (read-char port) (eat-whitespace))
;;           (if (char=? #\; (peek-char port))
;;               (begin (eat-comment)
;;                      (eat-whitespace)
;;                      ))))
;;     (define (fix-improper head tail)
;;       (if (null? head)
;;           tail
;;           (fix-improper (cdr head) (cons (car head) tail))))
;;     (define (read-list l)
;;       (eat-whitespace)
;;       (cond ((eof-object? (peek-char port))
;;              (error 
;;               "Input was terminated while looking for a closing parens."))
;;             ((char=? (peek-char port) #\)) (read-char port) (reverse l))
;;             (else 
;;              (let ((elem (read port)))
;;                (if (and (symbol? elem) (string=? "." (symbol->string elem)))
;;                    (let ((ans (fix-improper l (read port))))
;;                      (eat-whitespace)
;;                      (eat #\))
;;                      ans)
;;                    (read-list (cons elem l)))))))
;;     (define (read-string res)
;;       (let ((char (read-char port)))
;;         (cond ((eof-object? char) (list->string (reverse res)))
;;               ((char=? #\\ char) (read-string (cons (read-char port) res)))
;;               ((char=? #\" char) (list->string (reverse res)))
;;               (else (read-string (cons char res))))))
;;     (define (read-char-lit)
;;       (eat #\\)
;;       (case (peek-char port)
;;         ((#\; #\( #\) #\" #\;) (read-char port))
;;         ((#\space #\newline (integer->char 13))
;;          (error "Invalid character constant." (peek-char port)))
;;         (else
;;          (if (eof-object? (peek-char port))
;;              (error "Reached end-of-file in character constant.")
;;              (let ((name (read-until standard-delimiters)))
;;                (if (= (string-length name) 1)
;;                    (string-ref name 0)
;;                    (let ((char (assoc name '(("newline" . #\newline)
;;                                              ("space" . #\space)
;;                                              ("tab" . (integer->char #x09))))))
;;                      (if char
;;                          (cdr char)
;;                          (error "An invalid character name was specified."
;;                                 name)))))))))
;;     (define (parse-id-or-num string)
;;       (define n (string-length string))
;;       (define special-initial '(#\! #\$ #\% #\& #\* #\/ #\: #\< #\= #\> #\? #\^ #\_ #\~))
;;       (define special-subsequent '(#\+ #\- #\. #\@))
;;       (define peculiar-identifier '("+" "-" "." "..."))
;;       (define (ident-initial? c)
;;         (or (char-alphabetic? c)
;;             (memv c special-initial)))
;;       (define (ident-subsequent? c)
;;         (or (ident-initial? c)
;;             (char-numeric? c)
;;             (member c special-subsequent)))
;;       (define (valid-id? i)
;;         (if (>= i n)
;;             #t
;;             (and (ident-subsequent? (string-ref string i))
;;                  (valid-id? (+ i 1)))))
;;       (if (zero? n)
;;           (error "Read - unable to parse the empty string")
;;           (let ((first (string-ref string 0)))
;;             (cond ((member string peculiar-identifier)
;;                    (string->symbol string))
;;                   ((or (char-numeric? first)
;;                        (char=? first #\-))
;;                    (let ((result (string->number string)))
;;                      (if (not result)
;;                          (error "Unable to parse string as number" string)
;;                          result)))
;;                   ((ident-initial? first)
;;                    (if (valid-id? 1)
;;                        (string->symbol string)
;;                        (error "Unable to parse string as symbol" string)))
;;                   ((and (char=? #\# first)
;;                         (> n 1)
;;                         (char=? #\x (string-ref string 1)))
;;                    (let ((result (string->number (substring string 2 n) 16)))
;;                      (if result
;;                          result
;;                          (error "Unable to parse hex string as number" string))))
;;                   (else
;;                    (error "Unrecognized token" string))))))
;;     (let* ((char (read-char port))
;;            (next (if (eof-object? char) char (peek-char port))))
;;       (cond ((eof-object? char) char)
;;             ((char=? #\; char) (begin (eat-comment)
;;                                       (read port)))
;;             ((char-whitespace? char) (read port))
;;             ((and (char=? #\# char) (char=? #\\ next))
;;              (read-char-lit))
;;             ((and (char=? #\# char) (char=? #\t (char-downcase next)))
;;              (begin (read-char port)
;;                     #t))
;;             ((and (char=? #\# char) (char=? #\f (char-downcase next)))
;;              (begin (read-char port)
;;                     #f))
;;             ((and (char=? #\# char) (char=? #\( next))
;;              (read-char port) (list->vector (read-list '())))
;; ;#IFDEF READER_EXTENSIONS
;;             ((and (char=? #\# char) (assoc next *reader-extensions*))
;;              (let ((reader (cdr (assoc next *reader-extensions*))))
;;                (reader port)))
;; ;#ENDIF READER_EXTENSIONS
;;             ((char=? #\' char) (list 'quote (read port)))
;;             ((char=? #\` char) (list 'quasiquote (read port)))
;;             ((char=? #\, char) (if (char=? next #\@)
;;                                    (begin (read-char port)
;;                                           (list 'unquote-splicing
;;                                                 (read port)))
;;                                    (list 'unquote (read port))))
;;             ((char=? #\" char) (read-string '()))
;;             ((char=? #\( char)

;;              (read-list '()))
;;             (else
;;              (let ((the-string (string-append 
;;                                 (string char) 
;;                                 (read-until standard-delimiters))))
;;                (parse-id-or-num the-string))))))
;;   (read (if (null? port)
;;             (current-input-port)
;;             (car port))))

(define test-files '("tests/read.scm"
                     "tests/vararg.scm"
                     "tests/read4.scm"
                     "tests/read5.scm"
                     "tests/opeq.scm"
                     "tests/opminus.scm"
                     "tests/equal.scm"
                     "tests/r5rs2.scm"
                     ))

(define (go file)
  (call-with-input-file file
    (lambda (f)
      (let loop ((obj (read f)))
        (if (not (eof-object? obj))
            (begin
              (loop (read f))))))
    )
  (display ";; successfully read ")
  (display file)
  (newline))

(for-each go test-files)
