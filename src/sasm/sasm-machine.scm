;; sasm-achine.scm
;;
;; This module is responsible for simulating a register machine.  This is
;; used to implement the SASM runtime interpreter.
;;
;; This module was created by merging the old "regmach" and "regmach2"
;; modules from that library.  Previously this library was separate
;; from the SASM codebase.

(define (make-machine)
  (let ((regs '())
        (stack '())
        (arg-stack '())
        (stack-frames '())
        (locals-stack '())
        (flag #f)
        (push-count 0)
        (pop-count 0)
        (max-depth 0)
        (symconst '()) )
    (define (push obj)
;      (display "STACK++ [")
;      (display (length stack))
;      (display "] [")
;      (display obj)
;      (display "]")
;      (newline)
      (set! max-depth (max max-depth (+ 1 (length stack))))
      (set! push-count (+ 1 push-count))
      (set! stack (cons obj stack)))
    (define (pop)
      (set! pop-count (+ 1 pop-count))
      (let ((obj (car stack)))
        (set! stack (cdr stack))
;        (display "STACK-- [")
;        (display (length stack))
;        (display "] [")
;        (display obj)
;        (display "]")
;        (newline)
        obj))
    (define (push-arg obj)
      (set! arg-stack (cons obj arg-stack)))
    (define (pop-arg)
      (let ((obj (car arg-stack)))
        (set! arg-stack (cdr arg-stack))
        obj))
    (define (get-arg idx)
      (list-ref (car stack-frames) (+ idx 1)))
    (define (set-arg idx val)
      (define (iter idx l)
        (if (zero? idx)
            (set-car! l val)
            (iter (- idx 1) (cdr l))))
      (iter (+ idx 1) (car stack-frames)))
    (define (push-frame)
      (set! stack-frames (cons arg-stack stack-frames))
      (set! arg-stack '()))
    (define (pop-frame)
      (set! arg-stack (car stack-frames))
      (set! stack-frames (cdr stack-frames))
      (pop-locals))
    (define (dump-state)
      (display "@@@ dump-state") (newline)
      (display "locals: ") (display locals-stack) (newline)
      (display "arg-stack: ") (display arg-stack) (newline)
      (display "stack-frames: ") (display stack-frames) (newline))
    (define (pop-frame-tail-call n-next-args n-cur-args)
      (let ((ra (car (car stack-frames))))
        (set! stack-frames (cdr stack-frames))
        (push-arg ra))
      )
    (define (push-locals n)
      (set! locals-stack (cons (cons (make-vector n) '()) locals-stack)))
    (define (pop-locals)
      (set! locals-stack (cdr locals-stack)))
    (define (get-local idx)
      (vector-ref (caar locals-stack) idx))
    (define (set-local idx val)
      (vector-set! (caar locals-stack) idx val))
    (define (get-temp name)
      (cdr (assoc name (cdar locals-stack))))
    (define (set-temp name value)
      (let ((entry (assoc name (cdar locals-stack))))
        (if entry
            (set-cdr! entry value)
            (set-cdr! (car locals-stack) 
                      (cons (cons name value) 
                            (cdar locals-stack))))) )
    (define (read reg)
      (cdr (assoc reg regs)))
    (define (write reg val)
      (let ((v (assoc reg regs)))
        (if v
            (set-cdr! v val)
            (set! regs (cons (cons reg val) regs)))))
    (define (read-flag) flag)
    (define (write-flag val) (set! flag val))
    (define (stats)
      (list push-count pop-count max-depth))
    (define (set-symconst alist)
      (set! symconst alist))
    (define (get-symconst name)
      (let ((entry (assoc name symconst)))
        (or (and entry (cadr entry))
            (error "Invalid symbolic constant -- " name))))
    (define (machine sym . args)
      (apply (case sym
               ((push) push)
               ((pop) pop)
               ((push-arg) push-arg)
               ((pop-arg) pop-arg)
               ((get-arg) get-arg)
               ((set-arg) set-arg)
               ((push-frame) push-frame)
               ((pop-frame) pop-frame)
               ((pop-frame-tail-call) pop-frame-tail-call)
               ((push-locals) push-locals)
               ((pop-locals) pop-locals)
               ((get-local) get-local)
               ((set-local) set-local)
               ((get-temp) get-temp)
               ((set-temp) set-temp)
               ((read) read)
               ((write) write)
               ((read-flag) read-flag)
               ((write-flag) write-flag)
               ((dump-state) dump-state)
               ((stats) stats)
               ((set-symconst) set-symconst)
               ((get-symconst) get-symconst) )
             args))
    machine))

(define (machine-read-reg machine reg)
  (machine 'read reg))

(define (machine-write-reg machine reg value)
  (machine 'write reg value))

(define (machine-push machine value)
  (machine 'push value))

(define (machine-pop machine)
  (machine 'pop))

(define (machine-read-flag machine)
  (machine 'read-flag))

(define (machine-write-flag machine value)
  (machine 'write-flag value))

(define (machine-push-arg machine value)
  (machine 'push-arg value))

(define (machine-pop-arg machine)
  (machine 'pop-arg))

(define (machine-get-arg machine idx)
  (machine 'get-arg idx))

(define (machine-set-arg machine idx val)
  (machine 'set-arg idx val))

(define (machine-push-locals machine n-locals)
  (machine 'push-locals n-locals))

(define (machine-pop-locals machine)
  (machine 'pop-locals))

(define (machine-get-local machine idx)
  (machine 'get-local idx))

(define (machine-set-local machine idx val)
  (machine 'set-local idx val))

(define (machine-push-frame machine)
  (machine 'push-frame))

(define (machine-pop-frame machine)
  (machine 'pop-frame))

(define (machine-pop-frame-tail-call machine n-next-args n-cur-args)
  (machine 'pop-frame-tail-call n-next-args n-cur-args))

(define (machine-dump-regs machine)
  (machine 'dump-regs))

(define (machine-dump-stack machine)
  (machine 'dump-stack))

(define (machine-dump-state machine)
  (machine 'dump-state))

(define (machine-get-temp machine temp)
  (machine 'get-temp temp))

(define (machine-set-temp machine temp value)
  (machine 'set-temp temp value))

(define (machine-define-symconst! machine symconst-alist)
  (machine 'set-symconst symconst-alist))

(define (machine-lookup-symconst machine symconst)
  (machine 'get-symconst symconst))

(define (machine-valid-return-address? value)
  (or (equal? '$return-address value)
      (and (list? value)
           (= 3 (length value))
           (equal? '$return-address (car value))
           (symbol? (list-ref value 1)))))

(define (machine-return-address-context value)
  (list-ref value 1))

(define (machine-return-address-pc value)
  (list-ref value 2))

(define (make-machine2 . memory-size-specifier)
  (let* ((aux-regs '())
         (accum #f)
         (operand #f)
         (insn-pointer (* 8 1024))
         (stack-pointer (* 8 1024))
         (frame-pointer (* 8 1024))
         (stack-pointer-alias #f)
         (frame-pointer-alias #f)
         (reg-reader-cache `((accum . ,(lambda () accum))
                             (operand . ,(lambda () operand))
                             (stack-pointer . ,(lambda ()
                                                 stack-pointer))
                             (frame-pointer . ,(lambda ()
                                                 frame-pointer))
                             ))
         (reg-writer-cache `((accum . ,(lambda (x) (set! accum x)))
                             (operand . ,(lambda (x) (set! operand x)))
                             (stack-pointer . ,(lambda (x)
                                                 (set! stack-pointer x)))
                             (frame-pointer . ,(lambda (x)
                                                 (set! frame-pointer x)))
                             ))
         (flag #f)
         (temp-stack '())
         (sr-stack '())
         (call-context '$unknown)
         (memory-size (if (null? memory-size-specifier)
                          65536
                          (car memory-size-specifier)))
         (memory (make-vector memory-size '$invalid-memory))
         (base-machine (make-machine)) )
    (define (get-memory-size)
      memory-size)
    (define (set-sp! n)
      (if (< n 0)
          (error "Attempt to set negative stack pointer!" n))
      (if (< n 7000)
          (error "weird sp" stack-pointer n))
      (set! stack-pointer n))
    (define (println . args)
      (for-each display args) (newline))
    (define (push-stack obj)
      (set-sp! (- stack-pointer 1))
      (memory-set! stack-pointer obj))
    (define (pop-stack)
      (let ((obj (memory-ref stack-pointer)))
        (set-sp! (+ 1 stack-pointer))
        obj))
    (define (save val)
      (set-car! sr-stack (cons val (car sr-stack))))
    (define (restore)
      (let ((val (caar sr-stack)))
        (set-car! sr-stack (cdar sr-stack))
        val))
    (define (push-arg obj)
      (push-stack obj))
    (define (pop-arg)
      (pop-stack))
    (define (dump-stack)
      (display "STACK-DUMP\n")
      (let loop ((addr (* 8 1024)))
        (if (>= addr stack-pointer)
            (let ((value (memory-ref addr)))
              (if (machine-valid-return-address? value)
                  (println "   " addr " " `(return-address: ,(machine-return-address-context value)))
                  (println "   " addr " " (memory-ref addr)
                           (if (= frame-pointer addr)
                               " <-- frame-pointer"
                               "")))
              (loop (- addr 1))))))
    (define (get-arg idx)
;      (println "get-arg " idx "; " (vector-ref memory (+ frame-pointer 2 idx)))
;      (dump-stack)
      (memory-ref (+ frame-pointer 2 idx)))
    (define (set-arg idx val)
      (memory-set! (+ frame-pointer 2 idx) val))
    (define (push-frame)
      (push-stack frame-pointer)
      (set! frame-pointer stack-pointer))
    (define (pop-frame)
      (pop-frame-without-ra))
    (define (pop-frame-without-ra)
      (set-sp! frame-pointer)
      (set! frame-pointer (pop-stack))
; TODO: turn this return-address? check back on.  It was inconvenient
; for the code generated by the Scheme frontend but is very important
; for other code.  Obviously what I should do is add a different
; pop-frame instruction for Scheme which does not perform this check
; (perhaps performs some other sanity check that is relevant in the
; Scheme tail-call environment).
;
;      (if (not (machine-valid-return-address? (memory-ref stack-pointer)))
;          (error "bad return address" (memory-ref stack-pointer)))
      (pop-locals))
    (define (register-value-display-helper value)
      (cond ((and (pair? value)
                  (list? value)
                  (> (length value) 10))
             (display "long-list<")
             (display (list-ref value 0))
             (display " ")
             (display (list-ref value 1))
             (display "...>"))
            ((machine-valid-return-address? value)
             (display "return-address<")
             (display (machine-return-address-context value))
             (display ">"))
            (else
             (display value))))
    (define (dump-regs)
      (define (helper l)
        (for-each (lambda (x) 
                    (let ((value (cdr x)))
                      (display (car x))
                      (display "[")
                      (register-value-display-helper (cdr x))
                      (display "] ")))
                  l))
      (helper (append (list (cons 'accum accum)
                            (cons 'operand operand)
                            (cons 'flag flag))
                      (filter (lambda (x) (not (eqv? 'pc (car x))))
                              aux-regs)))
      (newline)
      (helper (list (cons 'stack-pointer stack-pointer)
                    (cons 'frame-pointer frame-pointer)
                    (cons 'insn-pointer insn-pointer)))
      (newline))
    (define (dump-temps)
      (if (not (null? temp-stack))
          (let ((temps (car temp-stack)))
            (for-each (lambda (x) 
                        (display (car x))
                        (display "[")
                        (register-value-display-helper (cdr x))
                        (display "] "))
                      temps)
            (newline))))
    (define (dump-state)
      (display "@@@ dump-state") (newline)
      (dump-regs)
      (dump-temps)
      (dump-stack))
    (define (pop-frame-tail-call n-next-args n-cur-args)
;      (println "pop-frame-tail-call " n-next-args " " n-cur-args)
;      (dump-stack)
      (set! operand (memory-ref (+ frame-pointer 1)))
      (push-stack operand)
      (set! accum (+ stack-pointer n-next-args))
      (pop-frame-without-ra)
;      (dump-stack)
      (set-sp! (+ stack-pointer n-cur-args))
      (let iter ((i 0))
        (if (< i n-next-args)
            (begin (set! operand (memory-ref accum))
                   (memory-set! stack-pointer operand)
                   (set! accum (- accum 1))
                   (set-sp! (- stack-pointer 1))
                   (iter (+ i 1)))))
      (set! operand (memory-ref accum))
      (memory-set! stack-pointer operand)
      (if (not (machine-valid-return-address? (memory-ref stack-pointer)))
          (error "bad return address in tail-call"))
;      (dump-stack)
      )
    (define (push-locals n)
      (set! temp-stack (cons '() temp-stack))
      (set! sr-stack (cons '() sr-stack))
      (set-sp! (- stack-pointer n)))
    (define (pop-locals)
      (set! temp-stack (cdr temp-stack))
      (set! sr-stack (cdr sr-stack)))
    (define (get-local idx)
      (memory-ref (- frame-pointer (+ 1 idx))))
    (define (set-local idx val)
      (memory-set! (- frame-pointer (+ 1 idx)) val))
    (define (get-temp name)
      (let ((entry (assoc name (car temp-stack))))
        (if (not entry)
            (error "Invalid temporary: " name))
        (cdr entry)))
    (define (set-temp name value)
      (let ((entry (assoc name (car temp-stack))))
        (if entry
            (set-cdr! entry value)
            (set-car! temp-stack
                      (cons (cons name value)
                            (car temp-stack))))))
    (define (reader reg)
      (define (aliased-reg-reader reg-symbol
                                  alias-variable
                                  alias-symbol)
        (if (and alias-variable
                 (eq? reg-symbol alias-variable))
            (let ((cached-reader (cdr (assoc alias-symbol
                                             reg-reader-cache))))
              (set! reg-reader-cache
                    (cons (cons alias-variable
                                cached-reader)
                          reg-reader-cache))
              cached-reader)
            #f))
      (let ((cached-reader (assoc reg reg-reader-cache)))
        (or (and cached-reader
                 (cdr cached-reader))
            (aliased-reg-reader reg
                                stack-pointer-alias
                                'stack-pointer)
            (aliased-reg-reader reg
                                frame-pointer-alias
                                'frame-pointer)
            (let ((reg-entry (assoc reg aux-regs)))
              (if (not reg-entry)
                  (error "Unknown register name (querying reader):"
                         reg))
              (let ((cached-reader (lambda () (cdr reg-entry))))
                (set! reg-reader-cache
                      (cons (cons reg cached-reader)
                            reg-reader-cache))
                cached-reader)))))
    (define (writer reg)
      (define (aliased-reg-writer reg-symbol
                                  alias-variable
                                  alias-symbol)
        (if (and alias-variable
                 (eq? reg-symbol alias-variable))
            (let ((cached-writer (cdr (assoc alias-symbol
                                             reg-writer-cache))))
              (set! reg-writer-cache
                    (cons (cons alias-variable
                                cached-writer)
                          reg-writer-cache))
              #t)
            #f))
      (let ((cached-writer (assoc reg reg-writer-cache)))
        (or (and cached-writer
                 (cdr cached-writer))
            (aliased-reg-writer reg
                                stack-pointer-alias
                                'stack-pointer)
            (aliased-reg-writer reg
                                frame-pointer-alias
                                'frame-pointer)
            (let ((reg-entry (assoc reg aux-regs)))
              (if (not reg-entry)
                  (error "Unknown register name (querying writer):"
                         reg))
              (let ((cached-writer (lambda (x) (set-cdr! reg-entry x))))
                (set! reg-writer-cache
                      (cons (cons reg cached-writer)
                            reg-writer-cache))
                cached-writer)))))
    (define (read reg)
      (case reg
        ((accum) accum)
        ((operand) operand)
        ((stack-pointer) stack-pointer)
        ((frame-pointer) frame-pointer)
        ((insn-pointer) (error "unable to read insn-pointer"))
        (else
         (cond ((and stack-pointer-alias (eq? reg stack-pointer-alias))
                stack-pointer)
               ((and frame-pointer-alias (eq? reg frame-pointer-alias))
                frame-pointer)
               (else
                (let ((reg-entry (assoc reg aux-regs)))
                  (if (not reg-entry)
                      (error "Attempt to read unknown register:" reg))
                  (cdr reg-entry)))))))
    (define (write reg val)
      (case reg
        ((accum) (set! accum val))
        ((operand) (set! operand val))
        ((stack-pointer) (set-sp! val))
        ((frame-pointer) (set! frame-pointer val))
        ((insn-pointer) (error "unable to write insn-pointer"))
        (else
         (cond ((and stack-pointer-alias (eq? reg stack-pointer-alias))
                (set-sp! val))
               ((and frame-pointer-alias (eq? reg frame-pointer-alias))
                (set! frame-pointer val))
               (else
                (let ((v (assoc reg aux-regs)))
                  (if v
                      (set-cdr! v val)
                      (set! aux-regs (cons (cons reg val) aux-regs)))))))))
    (define (read-flag) flag)
    (define (write-flag val) (set! flag val))
    (define (memory-ref addr)
      (if (zero? addr)
          (error "Attempt to dereference null"))
      (vector-ref memory addr))
    (define (memory-set! addr value)
      (if (zero? addr)
          (error "Attempt to assign null"))
      (vector-set! memory addr value))
    (define (stats)
      (list 0 0 0))
    (define (auxiliary-stack)
      (define (flatten-stack tx stack result)
        (if (null? stack)
            result
            (flatten-stack tx
                           (cdr stack)
                           (append (map tx (car stack)) result))))
      (list->vector (append (flatten-stack (lambda (x) x) sr-stack '())
                            (flatten-stack cdr temp-stack '()))))
    (define (machine sym . args)
      (apply (case sym
               ((push) save)
               ((pop) restore)
               ((push-arg) push-arg)
               ((pop-arg) pop-arg)
               ((get-arg) get-arg)
               ((set-arg) set-arg)
               ((push-frame) push-frame)
               ((pop-frame) pop-frame)
               ((pop-frame-tail-call) pop-frame-tail-call)
               ((push-locals) push-locals)
               ((pop-locals) pop-locals)
               ((get-local) get-local)
               ((set-local) set-local)
               ((get-temp) get-temp)
               ((set-temp) set-temp)
               ((read) read)
               ((write) write)
               ((get-reg-reader) reader)
               ((get-reg-writer) writer)
               ((read-flag) read-flag)
               ((write-flag) write-flag)
               ((dump-state) dump-state)
               ((dump-regs) dump-regs)
               ((dump-stack) dump-stack)
               ((memory-ref) memory-ref)
               ((memory-set!) memory-set!)
               ((stats) stats)
               ((get-memory-buffer) (lambda () memory))
               ((get-call-context) (lambda () call-context))
               ((set-call-context) (lambda (x) (set! call-context x)))
               ((set-sys-regs!) (lambda (stack frame)
                                  (set! stack-pointer-alias stack)
                                  (set! frame-pointer-alias frame)))
               ((show-sr-stack) (lambda () sr-stack))
               ((show-temp-stack) (lambda () temp-stack))
               ((memory-size) get-memory-size)
               ((auxiliary-stack) auxiliary-stack)
               (else (lambda args (apply base-machine sym args))) )
             args))
    machine))

(define (machine2-set-current-call-context machine context)
  (machine 'set-call-context context))

(define (machine2-get-current-call-context machine)
  (machine 'get-call-context))

(define (machine2-memory-ref machine addr)
  (machine 'memory-ref addr))

(define (machine2-memory-set! machine addr value)
  (machine 'memory-set! addr value))

(define (machine2-set-sys-registers! machine stack-pointer-alias frame-pointer-alias)
  (machine 'set-sys-regs! stack-pointer-alias frame-pointer-alias))

(define (machine2-dump-memory machine addr size)
  (define (justify s)
    (if (< (string-length s) 8)
        (justify (string-append "0" s))
        s))
  (let loop ((addr addr) (len 0))
    (if (< len size)
        (let ((val (machine2-memory-ref machine (+ addr len))))
          (println "   " (+ addr len) " " 
                   (if (number? val)
                       (string-append "#x" (justify (number->string val)) " "
                                      (number->string val))
                       val))
               (loop addr (+ len 1))))))

(define (machine2-reg-reader machine reg)
  (machine 'get-reg-reader reg))

(define (machine2-reg-writer machine reg)
  (machine 'get-reg-writer reg))

(define (machine2-memory-size machine)
  (machine 'memory-size))

(define (machine2-auxiliary-stack machine)
  (machine 'auxiliary-stack))
