(need pat/pat)
(need util/list)
(need util/string)
(need sasm/sasm-insn)
(need scheme/compiler/codegen/pretty-print)
(need scheme/compiler/labels)
(need scheme/meta-eval)

(define (replace obj env)
  (define (append-improper l obj)
    (if (null? l)
        obj
        (cons (car l)
              (append-improper (cdr l) obj))))
  (define (replace-as-list obj)
    (cond ((symbol? obj)
           (let ((rule (assoc obj env)))
             (let ((result (if rule (cdr rule) (list obj))))
               (if (list? result)
                   result
                   (list result)))))
          ((list? obj)
           (list (apply append (map replace-as-list obj))))
          (else (list (replace-helper obj)))))
  (define (replace-helper obj)
    (cond ((symbol? obj)
           (let ((rule (assoc obj env)))
             (if rule (cdr rule) obj)))
          ((list? obj)
           (apply append (map replace-as-list obj)))
          ((pair? obj)
           (append-improper (replace-as-list (car obj))
                            (replace-helper (cdr obj))))
          (else obj)))
  (replace-helper obj))

(define eval-env
  (let ((env (meta-eval-r5rs-environment)))
    (meta-eval `(define pretty-print
                  (quote ,(lambda (x) (pretty-print x *output*)
                                  (newline *output*))))
               env)
    (meta-eval '(define-syntax emit
                  (syntax-rules ()
                    ((_ <stmt> ...)
                     (begin (pretty-print `<stmt>)
                            ...))))
               env)
    (meta-eval `(define make-label-token (quote ,make-label-token))
               env)
    (meta-eval `(define make-label (quote ,make-label))
               env)
    (meta-eval `(define error (quote ,error))
               env)
    env))

(define (build-rewrite-env args)
  (append (map (lambda (x)
                 (cons x
                       (list `(arg ,(index-of x eqv? args)))))
               args)
          `((:enter (push (reg link))
                    (perform (op push-frame))
                    (perform (op reserve-locals) (const 0)))
            (:leave (perform (op pop-frame))
                    (pop (reg link))
                    (assign (sys stack-pointer) (op add-pointer)
                            (sys stack-pointer) (const ,(length args)))
                    (goto (reg link))))))

(define gc-array-mask -2147483648)

(define *input* #f)
(define *output* #f)

(let loop ((args (cdr (vector->list *argv*))))
  (define (opt? opt-name str)
    (or (equal? str (string-append "/" opt-name))
        (equal? str (string-append "-" opt-name))))
  (define (long-opt? opt-name str)
    (equal? str (string-append "--" opt-name)))
  (define (looks-like-opt? str)
    (or (starts-with? str "/")
        (starts-with? str "-")))
  (if (not (null? args))
      (let ((arg (car args))
            (rest (cdr args)))
        (cond ((and (not (null? rest))
                    (or (opt? "o" arg)
                        (long-opt? "output" arg)))
               (if *output*
                   (close-output-port *output*))
               (set! *output* (open-output-file (car rest)))
               (loop (cdr rest)))
              ((looks-like-opt? arg)
               (error "Unrecognized command-line option" arg))
              (else (if *input*
                        (error "more than one input file specified" arg))
                    (set! *input* (open-input-file arg))
                    (loop rest))))))

(if (not *input*)
    (set! *input* (current-input-port)))
(if (not *output*)
    (set! *output* (current-output-port)))


(let loop ((defn (read *input*)))
  (if (not (eof-object? defn))
      (let ((m (pattern-match `(define-glue ((,symbol? name) . (? args))
                                 . (? body))
                              defn)))
        (if m
            (let* ((name (cdr (assoc 'name m)))
                   (glue-name (string->symbol
                               (string-append "scmglue-"
                                              (symbol->string name))))
                   (closure-name (string->symbol
                                  (string-append "scmglue-closure-"
                                                 (symbol->string name))))
                   (global-name (make-sasm-label-for-global name)))

              (display ";;" *output*)
              (newline *output*)
              (display ";; " *output*)
              (display name *output*)
              (newline *output*)
              (display ";;" *output*)
              (newline *output*)
              (pretty-print `(export ,glue-name)
                            *output*)
              (newline *output*)
              (pretty-print `(export ,global-name)
                            *output*)
              (newline *output*)
              (pretty-print
               `(function
                 (name ,glue-name)
                 (locals 0)
                 (body ,@(let ((args (cdr (assoc 'args m))))
                           (replace (meta-eval (cons 'quasiquote
                                                     (list (cdr (assoc 'body m))))
                                               eval-env)
                                    (build-rewrite-env args)))))
               *output*)
              (newline *output*)
              (pretty-print `(global ,closure-name
                                     (const 0)
                                     (const ,(+ gc-array-mask 9))
                                     (const 0)
                                     (label ,glue-name))
                            *output*)
              (newline *output*)
              (newline *output*)
              (pretty-print `(global ,global-name
                                     (label ,closure-name))
                            *output*)
              (newline *output*)
              (newline *output*)
              (newline *output*)
              )
            (meta-eval defn eval-env))
        (loop (read *input*)))))

(close-input-port *input*)
(close-output-port *output*)
