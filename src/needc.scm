;; needc.scm
;;
;; pre-compiler tool for the (need foo/bar/baz) special-form.
;;
;; Supports (need x/y/z) syntax, and read-file-into-list-at-compile-time.

(define *needc-version* "generated by needc 02-09-2019 0.2")
(define *modules* '())
(define *root* "./")
(define *flat-module-names* #f)
(define *windows-mode* #f)
(define *expand-mode* #f)
(define *dir-sep* "/")

(define *output-fs* #f)
(define *output-modified* #f)

(define (read-fs file)
  (let ((s (stat file)))
    (cons s file)))

(define (fs-exists? fs)
  (and fs (pair? fs) (car fs)))

(define (fs-mod-time fs)
  (and (fs-exists? fs)
       (vector-ref (car fs) 9)))

(define (fs-newer? fs-a fs-b)
  (and (fs-exists? fs-a)
       (fs-exists? fs-b)
       (>= (fs-mod-time fs-a)
           (fs-mod-time fs-b))))

(define (accumulate-modified! file-name)
  (if (not (fs-exists? *output-fs*))
      (set! *output-modified* #t)
      (let ((fs (read-fs file-name)))
        ;; (display "newer? ")
        ;; (display file-name)
        ;; (display " ")
        ;; (display (fs-newer? fs *output-fs*))
        ;; (newline)
        (if (fs-newer? fs *output-fs*)
            (set! *output-modified* #t)))))

(define (rfilact module)
  (let ((file-name (string-append *root* module)))
    (accumulate-modified! file-name)
    (let ((in (open-input-file file-name)))
      (let loop ((result '()))
        (let ((obj (read in)))
          (if (eof-object? obj)
              (cons 'quote (list result))
              (loop (append result (list obj)))))))))

(define (evaluate-rfilact code)
  (cond ((and (pair? code)
              (eqv? 'read-file-into-list-at-compile-time (car code))
              (pair? (cdr code))
              (string? (car (cdr code)))
              (null? (cdr (cdr code))))
         (rfilact (car (cdr code))))
        ((pair? code)
         (cons (evaluate-rfilact (car code))
               (evaluate-rfilact (cdr code))))
        (else
         code)))

(define (module-loaded? module-name)
  (define (iter modules)
    (if (null? modules)
        #f
        (or (eqv? (car modules) module-name)
            (iter (cdr modules)))))
  (iter *modules*))

(define (load-module-port module-name input-port output-port)
  (let loop ((obj (read input-port)))
    (if (eof-object? obj)
        #t
        (begin
          (cond ((and (pair? obj)
                      (eqv? 'need (car obj))
                      (pair? (cdr obj))
                      (symbol? (car (cdr obj)))
                      (null? (cdr (cdr obj))))
                 (load-module! (car (cdr obj)) output-port)
                 (display ";; " output-port)
                 (display module-name output-port)
                 (newline output-port)
                 )
                (else
                 (let ((rewrite-obj (evaluate-rfilact obj)))
                   (write rewrite-obj output-port)
                   (newline output-port))))
          (loop (read input-port))))))

(define (load-module-file module-name file-name output-port)
  (display ";; load-module " output-port)
  (display module-name output-port)
  (display " " output-port)
  (display file-name output-port)
  (newline output-port)
  (let ((in (open-input-file file-name)))
    (load-module-port module-name in output-port)
    (close-input-port in)
    ))

(define (replace-characters-in-string string a b)
  (list->string (map (lambda (char)
                       (cond ((char=? a char) b)
                             (else char)))
                     (string->list string))))

(define (flatten-path-to-file-name path)
  (replace-characters-in-string path #\/ #\-))

(define (get-sasm-file-name path)
  (replace-extension (flatten-path-to-file-name path) ".sasm"))

(define (get-sasm-opt-file-name path)
  (replace-extension (flatten-path-to-file-name path) ".sasm-opt"))

(define (get-asm-file-name path)
  (replace-extension (flatten-path-to-file-name path) ".asm"))

(define (get-obj-file-name path)
  (replace-extension (flatten-path-to-file-name path)
		     (if *windows-mode*
			 ".obj"
			 ".o")))

(define (get-archive-file-name path)
  (replace-extension (flatten-path-to-file-name path) ".a"))

(define (env-var var-name)
  (if *windows-mode*
      (string-append "%" var-name "%")
      (string-append "$" var-name)))

(define (module-name-to-path module-name)
  (let ((path (symbol->string module-name)))
    (if *flat-module-names*
        (replace-characters-in-string path #\/ #\-)
        path)))

(define (load-module! module-name output-port)
  (if (not (module-loaded? module-name))
      (begin
        (set! *modules* (cons module-name *modules*))
        (let ((file-name (string-append *root*
                                        (module-name-to-path module-name)
                                        ".scm")))
          (display ";;  loading ")
          (display file-name)
          (newline)
          (load-module-file module-name file-name output-port)
          (accumulate-modified! file-name)
          )
        )
      ))

(define (string-starts-with? s suffix)
  (and (< (string-length suffix) (string-length s))
       (string=? (substring s 0 (string-length suffix))
                 suffix)))

(define (string-last-index-of string char)
  (let ((rest (member char (reverse (string->list string)))))
    (if rest
        (- (length rest) 1)
        -1)))

(define (replace-extension file-name new-extension)
  (define (get-suffix)
    (if (string-starts-with? new-extension ".")
        new-extension
        (string-append "." new-extension)))

  (let ((dot-index (string-last-index-of file-name #\.)))
    (if (> dot-index -1)
        (string-append (substring file-name 0 dot-index)
                       (get-suffix))
        (string-append file-name
                       (get-suffix)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generate script mode

(define (generate-script-port module-name input-port output-port)
  (let loop ((obj (read input-port)))
    (if (eof-object? obj)
        #t
        (begin
          (cond ((and (pair? obj)
                      (eqv? 'need (car obj))
                      (pair? (cdr obj))
                      (symbol? (car (cdr obj)))
                      (null? (cdr (cdr obj))))
                 (generate-script! (car (cdr obj)) output-port)
                 )
                (else #t))
          (loop (read input-port))))))

(define (generate-script-file module-name file-name output-port)
  (define (emit . args)
    (for-each (lambda (arg) (display arg output-port))
              args))
  (define (emit-line . args)
    (apply emit args)
    (newline output-port))
  (let ((port (open-input-file file-name)))
    (generate-script-port module-name port output-port)
    (display (string-append (if *windows-mode*
                                "@echo ;; compiling "
                                "echo ';; compiling ")
                            file-name
                            (if *windows-mode*
                                ""
                                "'"))
             output-port)
    (newline output-port)
    (emit-line (env-var "SCHEMEC")
               " "
               file-name
               " --outdir "
               (env-var "OUTDIR")
               " --conspiracy"
               (if *expand-mode*
                   " --expand-only"
                   (if (= *generate-script-depth* 1)
                       ""
                       " --no-entry")))
    (if *windows-mode*
        (emit-line "@if not \"%errorlevel%\"==\"0\" exit /b 1")
	(emit-line "if [ $? -ne 0 ]; then exit $?; fi")
	)
    (if (not *expand-mode*)
        (begin
          (emit-line (env-var "SASMOPT")
                     " "
                     (env-var "OUTDIR")
                     *dir-sep*
                     (get-sasm-file-name file-name)
                     " --out="
                     (env-var "OUTDIR")
                     *dir-sep*
                     (get-sasm-opt-file-name file-name)
                     " --cheap")
          (if *windows-mode*
              (emit-line "@if not \"%errorlevel%\"==\"0\" exit /b 1")
	      (emit-line "if [ $? -ne 0 ]; then exit $?; fi"))))

    (if (not *expand-mode*)
        (begin
          (emit-line (env-var "SASMC")
                     " "
                     (env-var "OUTDIR")
                     *dir-sep*
                     (get-sasm-opt-file-name file-name)
                     " --out="
                     (env-var "OUTDIR")
                     *dir-sep*
                     (get-asm-file-name file-name))
          (if *windows-mode*
              (emit-line "@if not \"%errorlevel%\"==\"0\" exit /b 1")
	      (emit-line "if [ $? -ne 0 ]; then exit $?; fi"))))

    (if (not *expand-mode*)
        (begin
          (emit-line "nasm -f" (if *windows-mode* "win32" "elf") " "
		     (env-var "OUTDIR") *dir-sep*
                     (get-asm-file-name file-name)
                     " -o " (env-var "OUTDIR") *dir-sep*
                     (get-obj-file-name file-name))
          (if *windows-mode*
              (emit-line "@if not \"%errorlevel%\"==\"0\" exit /b 1")
	      (emit-line "if [ $? -ne 0 ]; then exit $?; fi"))

          (if (not (= *generate-script-depth* 1))
              (begin
                (emit-line "ar rcs " (env-var "OUTDIR") *dir-sep* "lib"
                           (module-name-to-path *generate-script-main-module*)
                           ".a " (env-var "OUTDIR") *dir-sep*
                           (get-obj-file-name file-name))

                (if *windows-mode*
		    (emit-line "@if not \"%errorlevel%\"==\"0\" exit /b 1")
		    (emit-line "if [ $? -ne 0 ]; then exit $?; fi"))
                ))
          ))

    (close-input-port port)
    ))

(define *generate-script-depth* 0)
(define *generate-script-main-module* #f)
(define (generate-script! module-name output-port)
  (if (not (module-loaded? module-name))
      (begin
        (set! *generate-script-depth* (+ 1 *generate-script-depth*))
        (set! *modules* (cons module-name *modules*))
        (let ((file-name (string-append (symbol->string module-name)
                                        ".scm")))
          (generate-script-file module-name file-name output-port)
          (accumulate-modified! file-name))
        (set! *generate-script-depth* (- *generate-script-depth* 1))
        )
      ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generate makefile mode

(define (generate-makefile-port module-name input-port output-port)
  (let loop ((obj (read input-port))
             (deps '()))
    (if (eof-object? obj)
        (reverse deps)
        (begin
          (cond ((and (pair? obj)
                      (eqv? 'need (car obj))
                      (pair? (cdr obj))
                      (symbol? (car (cdr obj)))
                      (null? (cdr (cdr obj))))
                 (generate-makefile! (car (cdr obj)) output-port)
                 (loop (read input-port)
                       (cons (car (cdr obj)) deps)))
                (else (loop (read input-port)
                            deps)))))))

(define (generate-makefile-dep-symbol-name module-name)
  (let* ((str (symbol->string module-name))
         (repl1 (replace-characters-in-string str #\- #\_))
         (repl2 (replace-characters-in-string repl1 #\/ #\_)))
    (string-append "deps_of_" repl2)))

(define (generate-makefile-file module-name file-name output-port)
  (define (emit . args)
    (for-each (lambda (arg) (display arg output-port))
              args))
  (define (emit-line . args)
    (apply emit args)
    (newline output-port))
  (let* ((port (open-input-file file-name))
         (tab-char (integer->char 9))
         (tab-string (string tab-char))
         (deps-symbol (generate-makefile-dep-symbol-name module-name))
         (deps (generate-makefile-port module-name port output-port)))

    (if (and *expand-mode*
             (not (null? deps)))
        (begin
          (emit-line "## dependencies of " file-name)
          (emit-line deps-symbol "=" #\\)
          (for-each (lambda (dep)
                      (emit-line "  " dep ".scm " #\\))
                    deps)
          (emit-line "  # " (length deps) " dependencies")
          (emit-line)
          (emit-line)
          ))

    (for-each (lambda (dep)
                (if (not (member dep *generate-makefile-all-deps*))
                    (set! *generate-makefile-all-deps*
                          (cons dep *generate-makefile-all-deps*))))
              deps)

    ;; for each dependency:
    ;; %SCHEME% out\scheme-compiler-flat-ts.scm compat/tinyscheme.scm --outdir out\bootstrap --conspiracy --expand-only

    ;; to finish:
    ;; $(SCHEME) needc-ts.scm --root out\bootstrap --flat-names --output out\sasm-flat-ts.scm sasm-ts

    (close-input-port port)
    ))

(define *generate-makefile-depth* 0)
(define *generate-makefile-all-deps* '())
(define (generate-makefile! module-name output-port)
  (if (not (module-loaded? module-name))
      (begin
        (set! *generate-makefile-depth* (+ 1 *generate-makefile-depth*))
        (set! *modules* (cons module-name *modules*))
        (let ((file-name (string-append (symbol->string module-name)
                                        ".scm")))
          (generate-makefile-file module-name file-name output-port)
          (accumulate-modified! file-name))
        (set! *generate-makefile-depth* (- *generate-makefile-depth* 1))
        )
      ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (delete-if-exists! file-name)
  (if (fs-exists? (read-fs file-name))
      (begin
        (display ";; deleting ")
        (display file-name)
        (newline)
        (delete-file file-name))))

(define (rename-temp-file! file-name-tmp file-name)
  (delete-if-exists! file-name)
  (display ";; renaming ")
  (display file-name-tmp)
  (display " to ")
  (display file-name)
  (newline)
  (rename-file file-name-tmp file-name))

(define (version-check-prefix mode)
  (if (eqv? mode 'generate-script)
      (if *windows-mode*
	  "@echo "
	  "echo ")
      (if (eqv? mode 'generate-makefile)
          "# "
          ";; ")))

(define (check-output-version mode output-file)
  (let* ((version-prefix (version-check-prefix mode))
         (version (string-append version-prefix *needc-version*)))
    (call-with-input-file output-file
      (lambda (port)
        (let loop ((index 0))
          (let ((c (read-char port)))
            (cond ((eof-object? c) #f)
                  ((and (char=? c #\newline)
                        (= index (string-length version)))
                   #t)
                  ((>= index (string-length version)) #f)
                  ((not (char=? (string-ref version index) c))
                   #f)
                  (else (loop (+ index 1))))))))))

(let loop ((mode #f)
           (output-file #f)
           (rest-args (cdr (vector->list *argv*))))
  (cond ((null? rest-args)
         #t)
        ((or (string=? "--expand-only" (car rest-args))
             (string=? "--expand-syntax" (car rest-args)))
         (set! *expand-mode* #t)
         (display ";; enabled expand-only script mode")
         (newline)
         (loop mode output-file (cdr rest-args)))
        ((string=? "--script-mode" (car rest-args))
         (if mode
             (error "Mode already set"))
         (loop 'generate-script output-file (cdr rest-args)))
        ((string=? "--makefile-mode" (car rest-args))
         (if mode
             (error "Mode already set"))
         (loop 'generate-makefile output-file (cdr rest-args)))
        ((string=? "--windows-mode" (car rest-args))
         (set! *windows-mode* #t)
         (set! *dir-sep* (string #\\))
         (loop mode output-file (cdr rest-args)))
        ((string=? "--root" (car rest-args))
         (if (null? (cdr rest-args))
             (error "Invalid command line, no argument to --root"))
         (display ";; updating root to ")
         (display (car (cdr rest-args)))
         (newline)
         (set! *root* (string-append (car (cdr rest-args)) "/"))
         (loop mode output-file (cdr (cdr rest-args))))
        ((string=? "--flat-names" (car rest-args))
         (set! *flat-module-names* #t)
         (loop mode output-file (cdr rest-args)))
        ((string=? "--output" (car rest-args))
         (if (null? (cdr rest-args))
             (error "Invalid command line, no argument to --output"))
         (display ";; producing output file ")
         (display (car (cdr rest-args)))
         (newline)
         (loop mode (car (cdr rest-args)) (cdr (cdr rest-args))))
        (else
         (if (not (null? (cdr rest-args)))
             (error "bad command line, extra arguments"))
         (let* ((output-fs (read-fs output-file))
                (tmp-output-file (if output-file
                                     (string-append output-file ".tmp")
                                     #f))
                (unused (if tmp-output-file
                            (delete-if-exists! tmp-output-file)))
                (tmp-output-port (if tmp-output-file
                                     (open-output-file tmp-output-file)
                                     (current-output-port))))
           (define (emit . args)
             (for-each (lambda (arg) (display arg tmp-output-port))
                       args))
           (define (emit-line . args)
             (apply emit args)
             (newline tmp-output-port))

           (if output-fs
               (set! *output-fs* output-fs))

           (if (fs-exists? *output-fs*)
               (let ((match (check-output-version mode output-file)))
                 (if (not match)
                     (begin (display ";; needc version updated, modifying script")
                            (newline)
                            (set! *output-modified* #t)))))

           (if (and *expand-mode* (not mode))
               (error "bad command line, expand-mode without mode"))

           (if (eqv? 'generate-script mode)
               (begin (emit-line (version-check-prefix mode) *needc-version*)
                      (if *windows-mode*
                          (emit-line "@setlocal")
                          )
                      (set! *generate-script-main-module* (string->symbol (car rest-args)))
                      (generate-script! *generate-script-main-module*
                                        tmp-output-port))
               (if (eqv? 'generate-makefile mode)
                   (begin (emit-line (version-check-prefix mode) *needc-version*)
                          (emit-line)
                          (generate-makefile! (string->symbol (car rest-args))
                                              tmp-output-port)

                          (let ((main-symbol (generate-makefile-dep-symbol-name (string->symbol (car rest-args)))))
                            (emit-line main-symbol "=" #\\)
                            (for-each (lambda (dep)
                                        (emit-line "  " dep ".scm " #\\))
                                      (reverse *generate-makefile-all-deps*))
                            (emit-line "  # " (length *generate-makefile-all-deps*) " dependencies listed")
                            (emit-line)
                            ))
                   (load-module! (string->symbol (car rest-args))
                                 tmp-output-port)))

           (if tmp-output-file
               (close-output-port tmp-output-port))

           ;; (display "output exists? ")
           ;; (display (fs-exists? output-file))
           ;; (newline)

           ;; (display "output-modified ")
           ;; (display *output-modified*)
           ;; (newline)

           (if (or (not (fs-exists? *output-fs*))
                   (and tmp-output-file *output-modified*))
               (begin
                 (delete-if-exists! output-file)
                 (rename-temp-file! tmp-output-file output-file))
               (begin
                 (display ";; ")
                 (display output-file)
                 (display " up-to-date")
                 (newline))
               )

           (if tmp-output-file
               (delete-if-exists! tmp-output-file))

           ))))
