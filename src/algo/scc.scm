(define (memq-reverse a b)
  (define (iter result rest)
    (cond ((null? rest) #f)
          ((eq? a (car rest)) (cons (car rest) result))
          (else (iter (cons (car rest) result) (cdr rest)))))
  (iter '() b))

(define (find-scc nodes node-neighbors)
  (let ((id 0)
;        (ids '())
        (ids (multi-hash))
        (in-stack (multi-hash))
        (stack '())
        (scc-list (list-builder)))
    (define (id++) (set! id (+ id 1)) id)
;    (define (get-node node) (let ((r (assoc node ids))) (and r (cdr r))))
    (define (get-node node) (let ((r (multi-hash-lookup ids node))) (and r (string->number (vector-ref r 0)))))
;    (define (set-node! node i) (set! ids (cons (cons node i) ids)))
    (define (set-node! node i) (multi-hash-set! ids node (number->string i)))
;    (define (push-node! node) (set! stack (cons node stack)))
    (define (push-node! node) (set! stack (cons node stack)) (multi-hash-set! in-stack node ""))
;    (define (done? node) (and (get-node node) (not (member node stack))))
    (define (done? node) (and (multi-hash-lookup ids node) (not (multi-hash-lookup in-stack node))))
    (define (pop-node node) 
      (let ((res (memq-reverse node stack))) 
        (set! stack (cdr (memq node stack))) 
        (for-each (lambda (n) (multi-hash-erase! in-stack n)) 
                  res)
        (multi-hash-erase! in-stack node)
        res))
    (define (visit node)
      (if (not (string? node))
          (begin (display "node is not string: ") (write node) (newline)))
      (let ((c (get-node node)))
        (if c 
            c
            (let ((new-id (id++)))
              (set-node! node new-id)
              (push-node! node)
              (let ((comp (apply min (cons new-id (map (lambda (n)
                                                         (if (done? n)
                                                             (+ new-id 1)
                                                             (visit n)))
                                                       (node-neighbors node))))))
                (if (= new-id comp)
                    (let ((scc (pop-node node)))
                      ;(write scc)
                      ;(newline)
                      (list-build! scc-list scc)
                      ))
                comp)))))
    (for-each visit nodes)
    (list-finalize! scc-list)))
