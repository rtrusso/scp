# Old Readme

This project started out as a graduate school project at the
University of Washington. The documentation below was converted to
markdown and preserved because it might still be helpful.

# Compiler Project README

http://www.cs.washington.edu/homes/rrusso/compiler/

# Table of Contents

1. Unpacking the compiler
2. Running the compiler using the makefile
3. Running the SASM interpreter
4. Running the compiled code
5. Running the test suite

# 1. Unpacking the compiler

The project is archived in ZIP format and available for download on my
website.  The archive is named with the version, and it will unpack
into a directory that has the same name (i.e. rrusso-project-0.1.zip
unpacks into a directory named rrusso-project-0.1).

# 2. Running the compiler and using the makefile

Running the compiler and interpreter takes very little setup.  In the
directory where you unpacked the project, there will be a makefile.
This makefile will help automate running several phases of the
compiler.  This is an academic project and not a commercial product,
so the phases of the compiler are not wrapped up in a single
commandline shell. But luckily, this makefile will help automate
things.

The main dependency for running the compiler and interpreter is
mzscheme from the PLT Scheme distribution.  That is available for
download from http://www.plt-scheme.org/.  If you happen to be another
UW computer science student, you can use the copy that is installed on
Attu.

With mzscheme in place, you can begin compiling MiniJava programs.
Here's an example:

    > make TwoArgs.asm
    mzscheme --script run.scm compiler.scm tests/TwoArgs.java >TwoArgs.sasm
    mzscheme --script run.scm sasm-opt.scm TwoArgs.sasm >TwoArgs.sasm-opt
    mzscheme --script run.scm sasm.scm TwoArgs.sasm-opt >TwoArgs.asm

The makefile takes care of running the base compiler, the optimizer,
and then the final translation step that produces x86 assembly.  If
you want to run the MIPS version of the compiler, you issue a
different makefile command:

    > make TwoArgs-spim.s
    mzscheme --script run.scm sasm-opt-mips.scm TwoArgs.sasm >TwoArgs.sasm-opt-mips
    mzscheme --script run.scm sasm-mips.scm TwoArgs.sasm-opt-mips >TwoArgs.s
    mzscheme --script run.scm sasm-opt-mips.scm rtl/mjrtl-mips.sasm >mjrtlp.sasm-opt-mips
    mzscheme --script run.scm sasm-mips.scm mjrtlp.sasm-opt-mips >mjrtlp-mips.s
    mzscheme --script run.scm sasm-opt-mips.scm rtl/heap.sasm >heap-mips.sasm
    mzscheme --script run.scm sasm-mips.scm heap-mips.sasm >heap-mips.s
    mzscheme --script run.scm sasm-opt-mips.scm rtl/gc.sasm >gc-mips.sasm
    mzscheme --script run.scm sasm-mips.scm gc-mips.sasm >gc-mips.s
    mzscheme --script run.scm sasm-opt-mips.scm rtl/c-rtlheap.sasm >rtlheap-mips.sasm
    mzscheme --script run.scm sasm-mips.scm rtlheap-mips.sasm >rtlheap-mips.s
    cat rtl/spim-main.s mjrtlp-mips.s heap-mips.s gc-mips.s rtlheap-mips.s TwoArgs.s >TwoArgs-spim.s

Notice that a lot more commands get run.  All this extra work is
because the runtime library (heap management and GC) is being
translated into MIPS assembly, and inlined right there to form a
final, standalone MIPS assembly source file you can run inside SPIM.

I've been using "TwoArgs" as an example here, but it is just one test
from the "tests" directory.  If you look in that directory you will
notice several test input programs.  You can compile any of these;
just substitute the name for TwoArgs in the commands above.  Some of
these programs come from the original MiniJava project website,
because I used them as test programs in my original project for
CSEP501.

You can choose to run only a particular phase of the compiler, by
issuing a different make command.  For instance, suppose you want to
run just the optimizer and you don't want to generate X86 assembly.
In that case you can run this command:

    > make TwoArgs.sasm-opt
    mzscheme --script run.scm compiler.scm tests/TwoArgs.java >TwoArgs.sasm
    mzscheme --script run.scm sasm-opt.scm TwoArgs.sasm >TwoArgs.sasm-opt

If all of the intermediate files are making a mess in the directory,
you can run a clean command:

    > make clean


# 3. Running the SASM interpreter

The SASM interpreter is very simple to run and introduces no
additional dependencies other than the one needed to run the basic
compiler (make and mzscheme).

To run the compiler, use the ".actual" makefile rule.  The name is
intended to represent "actual program output" as opposed to the output
generated by the program when compiled by a known-good Java compiler.

Here is an example using the old TwoArgs example:

    > make TwoArgs.actual
    mzscheme --script run.scm compiler.scm tests/TwoArgs.java >TwoArgs.sasm
    mzscheme --script run.scm sasm-interp.scm rtl/heap.sasm rtl/gc.sasm rtl/rtlheap.sasm TwoArgs.sasm >TwoArgs.actual

Notice that the optimization phase is not run.  It is possible to run
the interpreter on optimized code; in fact this is something I
definitely took advantage of to help verify my optimizer before
generating native code.  But by default this makefile rule just runs
the SASM interpreter against the unoptimized SASM output.

You can use this same command for any program in the "tests"
directory, just substitute the name in the above command.

Notice that the interpreter is executed with 4 actual input files:
heap.sasm, gc.sasm, rtlheap.sasm, and finally the actual input program
to interpret.  The other three SASM programs are the runtime library
that implement heap management and GC.  The SASM interpreter can
operate in a very high-level symbolic mode, or it can operate in a
lower-level machine mode so that low-level programs like the heap
manager and GC can run.

# 4. Running the compiled code ==

## Running X86 Code

Running the compiled X86 code may be something of a pain because of
all of the dependencies required.  But if you have them, the makefile
should help you automate this process completely.

First off, the only platform on which running the X86 code was tested
is a Cygwin environment running on a 32-bit version of Windows XP.  In
that environment, GCC v3.4.4 was used to compile C code and link
object files, and NASM v0.98.39 was used to assemble the output code
of my compiler.  It should be very possible to run the code on other
platforms but it hasn't been tested and likely will hit a snag here or
there during compilation/linking.

Cygwin is available for download at: http://www.cygwin.com/.
NASM is available at: http://sourceforge.net/projects/nasm/.

If you have all of the right dependencies, you should be able to run
the X86 code with a simple makefile command:

    > make TwoArgs.native-actual
    mzscheme --script compiler.scm tests/TwoArgs.java >TwoArgs.sasm
    mzscheme --script sasm-opt.scm TwoArgs.sasm >TwoArgs.sasm-opt
    mzscheme --script sasm.scm TwoArgs.sasm-opt >TwoArgs.asm
    mzscheme --script sasm-opt.scm rtl/heap.sasm >heap-x86.sasm
    mzscheme --script sasm.scm heap-x86.sasm >heap-x86.asm
    nasmw -fwin32 heap-x86.asm
    mzscheme --script sasm-opt.scm rtl/gc.sasm >gc-x86.sasm
    mzscheme --script sasm.scm gc-x86.sasm >gc-x86.asm
    nasmw -fwin32 gc-x86.asm
    mzscheme --script sasm-opt.scm rtl/c-rtlheap.sasm >rtlheap-x86.sasm
    mzscheme --script sasm.scm rtlheap-x86.sasm >rtlheap-x86.asm
    nasmw -fwin32 rtlheap-x86.asm
    mzscheme --script sasm-opt.scm rtl/mjrtl.sasm >mjrtlp.sasm-opt
    mzscheme --script sasm.scm mjrtlp.sasm-opt >mjrtlp.asm
    nasmw -fwin32 mjrtlp.asm
    nasmw -fwin32 TwoArgs.asm
    gcc rtl/mjrtl.c TwoArgs.obj heap-x86.obj gc-x86.obj rtlheap-x86.obj mjrtlp.obj
    ./a.exe >TwoArgs.native-actual

The ".native-actual" rule is getting a bit long, but stands for
"actual program output, generated by native code".  Actual output as
opposed to output generated by the program when compiled by a
known-good Java compiler; native as opposed to running under the SASM
interpreter.

Once again this looks like a lot of commands, but it shows the
makefile automatically compiling and assembling the heap management
and GC routines for the runtime library.  Usually this only needs to
be done once and then you can compile and run other X86 code without
redoing all of that work.

## Running the MIPS Code

Running the MIPS code is much easier because it has far fewer
dependencies.  Namely, you'll just need PC SPIM.  You can get PC SPIM
from James Larus' website:

http://www.cs.wisc.edu/~larus/spim.html

PC SPIM is small to download and simple to install.  If you wanted to
try out my project and don't want to spend a lot of time setting up
cygwin, GCC and NASM, this is probably your best bet.

I've only tested my MIPS output running on PC SPIM with the default
settings.  There are other builds of SPIM there and lots of options
that you can use to configure SPIMs runtime behavior.  While it should
be possible to get the code running in any situation, just be warned
that only that configuration is tested.

The steps above in section 2 demonstrate how to build a "*-spim.s"
file.  This assembly source file is a completely self-contained
program that you can feed into SPIM.  It includes all of the compiled
MIPS code from the original MiniJava source program, plus the whole
runtime library inlined.

You should be able to simply load up that "*-spim.s" file in SPIM and
press the "go" button (F5 is the hotkey in the build I am using).  The
"System.out.println" statements in the MiniJava program should be
reflected in the Console window of PC SPIM.  They will be prefixed
with "@SYSTEM-OUT-PRINTLN".  You can use the "fix-spimout.scm" program
to strip out these lines from stdin and produce a clean output file on
stdout that you can diff against the expected output.  I did it this
way because I couldn't get SPIM to leave out any header lines and just
print my output.  So instead I went with this prefix/cleanup solution
to help automate things.

# 5. Running the test suite

Running the test suite again has only been tested on the WinXP/Cygwin
platform.  It adds an additional requirement, which is GCJ, or the GNU
Compiler for Java.  GCJ is a native code compiler for Java.  Like the
rest of GCC, it is available for installation through Cygwin so if you
already have that, it's the easiest way to get it.

After you get GCJ installed, you can just run a few simple makefile
rules to test the output of the interpreter, or actual compiled X86
code.  Use this example to diff the interpreter against the output of
GCC:

    > make TwoArgs.test
    mzscheme --script sasm-interp.scm rtl/heap.sasm rtl/gc.sasm rtl/rtlheap.sasm TwoArgs.sasm >TwoArgs.actual
    diff TwoArgs.out TwoArgs.actual >TwoArgs.test

This example uses the "*.test" rule.  You can use it for any program
in the "tests" directory.  If the output files match, diff will return
a 0 status code and the make operation will succeed.  If the files do
not match, diff returns a nonzero code and the make operation fails.

This example will allow you to diff the GCJ output against the output
of the program as compiled by my X86 compiler:

    > make TwoArgs.ntest
    gcj --main=TwoArgs tests/TwoArgs.java
    ./a.exe >TwoArgs.out
    diff TwoArgs.out TwoArgs.native-actual >TwoArgs.ntest

The rule to use in this case is "*.ntest", for "native test".

